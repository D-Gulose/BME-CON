/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module DIG_D_FF_AS_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input Set,
   input [(Bits-1):0] D,
   input C,
   input Clr,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= {Bits{1'b1}};
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module nextstatelogic_gates (
  input \state_{now,1} ,
  input \state_{now,0} ,
  input start_i,
  input \divisornot=0 ,
  input \subtrahend>=divisor ,
  output \state_{next,1} ,
  output \state_{next,0} 
);
  wire s0;
  assign s0 = ~ \state_{now,1} ;
  assign \state_{next,1}  = ~ (~ (~ \divisornot=0  & start_i & s0) & ~ (\state_{now,0}  & ~ \subtrahend>=divisor ));
  assign \state_{next,0}  = ~ (~ (\divisornot=0  & start_i & ~ \state_{now,0}  & s0) & ~ (\state_{now,0}  & \subtrahend>=divisor ));
endmodule

module statemachine (
  input start_i,
  input \divisornot=0 ,
  input \substrahend>=divisor ,
  input clk,
  input reset_i,
  output [1:0] state
);
  wire [1:0] s0;
  wire [1:0] state_temp;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  DIG_D_FF_AS_Nbit #(
    .Bits(2),
    .Default(0)
  )
  DIG_D_FF_AS_Nbit_i0 (
    .Set( 1'b0 ),
    .D( s0 ),
    .C( clk ),
    .Clr( reset_i ),
    .Q( state_temp )
  );
  nextstatelogic_gates nextstatelogic_gates_i1 (
    .\state_{now,1} ( s4 ),
    .\state_{now,0} ( s3 ),
    .start_i( start_i ),
    .\divisornot=0 ( \divisornot=0  ),
    .\subtrahend>=divisor ( \substrahend>=divisor  ),
    .\state_{next,1} ( s2 ),
    .\state_{next,0} ( s1 )
  );
  assign s0[0] = s1;
  assign s0[1] = s2;
  assign s3 = state_temp[0];
  assign s4 = state_temp[1];
  assign state = state_temp;
endmodule

module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module divider_inside (
  input [3:0] dividend_i,
  input [3:0] divisor_i,
  input start_i,
  input clk_i,
  input reset_i,
  output busy_o,
  output finish_o,
  output [4:0] quotient_o
);
  wire [4:0] s0;
  wire [4:0] quotient_o_temp;
  wire [1:0] s1;
  wire [3:0] s2;
  wire [3:0] s3;
  wire [4:0] s4;
  wire [4:0] s5;
  wire [4:0] s6;
  wire s7;
  wire s8;
  wire s9;
  wire [3:0] s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire [4:0] s15;
  CompUnsigned #(
    .Bits(4)
  )
  CompUnsigned_i0 (
    .a( divisor_i ),
    .b( 4'b0 ),
    .\> ( s7 ),
    .\= ( s8 ),
    .\< ( s9 )
  );
  assign s13 = (s7 | s9);
  // quotient
  DIG_D_FF_AS_Nbit #(
    .Bits(5),
    .Default(0)
  )
  DIG_D_FF_AS_Nbit_i1 (
    .Set( 1'b0 ),
    .D( s0 ),
    .C( clk_i ),
    .Clr( reset_i ),
    .Q( quotient_o_temp )
  );
  // subtrahend
  DIG_D_FF_AS_Nbit #(
    .Bits(4),
    .Default(0)
  )
  DIG_D_FF_AS_Nbit_i2 (
    .Set( 1'b0 ),
    .D( s2 ),
    .C( clk_i ),
    .Clr( reset_i ),
    .Q( s3 )
  );
  Mux_4x1_NBits #(
    .Bits(4)
  )
  Mux_4x1_NBits_i3 (
    .sel( s1 ),
    .in_0( dividend_i ),
    .in_1( s10 ),
    .in_2( s3 ),
    .in_3( 4'b0 ),
    .out( s2 )
  );
  DIG_Sub #(
    .Bits(4)
  )
  DIG_Sub_i4 (
    .a( s3 ),
    .b( divisor_i ),
    .c_i( 1'b0 ),
    .s( s10 )
  );
  CompUnsigned #(
    .Bits(4)
  )
  CompUnsigned_i5 (
    .a( s3 ),
    .b( divisor_i ),
    .\> ( s11 ),
    .\= ( s12 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i6 (
    .sel( s8 ),
    .in_0( quotient_o_temp ),
    .in_1( 5'b11111 ),
    .out( s6 )
  );
  statemachine statemachine_i7 (
    .start_i( start_i ),
    .\divisornot=0 ( s13 ),
    .\substrahend>=divisor ( s14 ),
    .clk( clk_i ),
    .reset_i( reset_i ),
    .state( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i8 (
    .sel( s8 ),
    .in_0( 5'b0 ),
    .in_1( s6 ),
    .out( s4 )
  );
  Mux_4x1 Mux_4x1_i9 (
    .sel( s1 ),
    .in_0( 1'b0 ),
    .in_1( 1'b1 ),
    .in_2( 1'b0 ),
    .in_3( 1'b0 ),
    .out( busy_o )
  );
  Mux_4x1 Mux_4x1_i10 (
    .sel( s1 ),
    .in_0( 1'b0 ),
    .in_1( 1'b0 ),
    .in_2( 1'b1 ),
    .in_3( 1'b0 ),
    .out( finish_o )
  );
  assign s14 = (s11 | s12);
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i11 (
    .sel( s14 ),
    .in_0( 5'b0 ),
    .in_1( 5'b1 ),
    .out( s15 )
  );
  DIG_Add #(
    .Bits(5)
  )
  DIG_Add_i12 (
    .a( quotient_o_temp ),
    .b( s15 ),
    .c_i( 1'b0 ),
    .s( s5 )
  );
  Mux_4x1_NBits #(
    .Bits(5)
  )
  Mux_4x1_NBits_i13 (
    .sel( s1 ),
    .in_0( s4 ),
    .in_1( s5 ),
    .in_2( s6 ),
    .in_3( 5'b0 ),
    .out( s0 )
  );
  assign quotient_o = quotient_o_temp;
endmodule

module divider (
  input clk_i,
  input reset_i,
  input [3:0] dividend_i,
  input [3:0] divisor_i,
  input start_i,
  output busy_o,
  output finish_o,
  output [4:0] quotient_o
);
  divider_inside divider_inside_i0 (
    .dividend_i( dividend_i ),
    .divisor_i( divisor_i ),
    .start_i( start_i ),
    .clk_i( clk_i ),
    .reset_i( reset_i ),
    .busy_o( busy_o ),
    .finish_o( finish_o ),
    .quotient_o( quotient_o )
  );
endmodule
